\documentclass{article}

% Fonts
\usepackage{fontspec}

% General formatting
\usepackage[margin=1.3in, headheight=3ex, headsep=3ex]{geometry}
\usepackage{fancyhdr}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{multirow}

% Colour
\usepackage[usenames,dvipsnames]{xcolor}

% Hyperlinks
\usepackage{url}
\usepackage{hyperref}

% Course details
\newcommand{\longcoursename}{
    Student Taught Courses (StuCo): Shilling the Rust Programming Language
}

\newcommand{\shortcoursename}{STUCO: RUSTLANG}
\newcommand{\courselocation}{WeH 5302}
\newcommand{\meetingstarttime}{19:00}
\newcommand{\meetingendtime}{19:50}
\newcommand{\meetingdays}{Wednesday}
\newcommand{\longsemester}{Spring 2023}
\newcommand{\shortsemester}{S23}
\newcommand{\academicyear}{2022-23}
\newcommand{\deptcode}{98}
\newcommand{\coursecode}{008}
\newcommand{\fullcoursecode}{\deptcode-\coursecode}

% Headers and Footers
\pagestyle{fancy}
\lhead{Pierce; Duvall}
\rhead{\fullcoursecode\ \shortsemester}

\begin{document}
\thispagestyle{empty}
\begin{center}
    \begin{minipage}{.85\textwidth}
        \centering
        {\huge {\fullcoursecode} Homework 1: PPM Parsing}

        \vspace{1em}

        \begin{tabular}{@{}rl@{}}
            Cooper Pierce & \multirow{2}*{\href{mailto:rust-stuco-staff@lists.andrew.cmu.edu}{\texttt{rust-stuco-staff@lists.andrew.cmu.edu}}} \\
            Jack Duvall &                                                                         \\
            
        \end{tabular}

        \vspace{1em}

        \longsemester
    \end{minipage}
\end{center}


\section*{Overview}

The goal of assignment is to get you used to basic Rust constructs and syntax, filling out the core of a program that actually does something useful! We hope this will give you familiarity with Rust's development workflow and start to get you comfortable with using the language.

You'll probably encounter compiler messages you don't understand as part of this. Feel free to ask about these in Discord; odds are somebody else is running into something similar! Discussing the assignment and problems you're running into is okay, but please don't copy code verbatim from other students. You should understand, to the greatest extent possible, all code you submit.

This assignment will have you write a basic parser for a simple image format known as PPM.

\section*{PPM Images}
PPM is a very simple image format, consisting of just:
\begin{itemize}
    \item A \href{https://en.wikipedia.org/wiki/List_of_file_signatures}{``magic number''} to distinguish it from other files
    \item The width and height of the image
    \item The maximum intensity value of
    \item Pixels as packed RGB pixel values, read sequentially row-by-row
          (i.e., row-major) from the top left of the image.
\end{itemize}

\url{http://ailab.eecs.wsu.edu/wise/P1/PPM.html} outlines the format; for simplicity, we'll summarize it again here. Note that we'll be using the binary format, where each pixel channel takes up exactly one byte.

\subsection*{PPM Grammar}

The grammar for PPM files is as follows:

\begin{verbatim}
<ppm>        ::= <magic-num>
                 (<comment> | <whitespace>)+ <width>
                 (<comment> | <whitespace>)+ <height>
                 (<comment> | <whitespace>)+ <maxval>
                 \n <pixels>
<magic-num>  ::= P6\n
<whitespace> ::= \t | \n | \x0C | \r | ' ' (i.e., a literal space)
<comment>    ::= # [^\n]* \n
<width>      ::= [0-9]+
<height>     ::= [0-9]+
<maxval>     ::= [0-9]+
<pixels>     ::= [\x00-\xFF]*
\end{verbatim}

There is also an additional constraint that the number of bytes parsed for pixels shall be exactly \(3wh\) where \(w\) and \(h\) are the parsed width and height, respectively.

Some assistance with reading the table above, if you haven't seen BNF-like grammar specifications before:
\begin{itemize}
    \item nonterminals (a name for a class of actual character sequences) are surrounded by angle brackets and are defined by production rules given on the right of a \texttt{::=}.
    \item the \texttt{|} operator expresses that either the left, or the right side can be chosen (e.g., \texttt{<whitespace>} can match any single newline, tab, etc..).
    \item the \texttt{+} and \texttt{*} operators express that the object to the left can be repeated 1 or more times or 0 or more times, respectively.
    \item ranges in square brackets express choice between the characters comprising the range; or the complement, if the initial character is a caret.
\end{itemize}

\subsection*{PPM Image Example}

An example would probably help understand the above specification a bit:

\begin{verbatim}
P6
# I'm a PPM file! You can tell by the magic header
3 3 # This first number is the width, and the second is the height
# This next number is the maximum intensity of each pixel
# Exporting as "raw" in GIMP always gives 255, which makes sense; this is the
# maximum value of a u8. After this maxval, we are only allowed a single newline
# before the pixels start. These pixels can be arbitrary bytes!
255
<<<<<<<<<aaaaaaaaa~~~~~~~~~
\end{verbatim}

Copy-pasting this text into a file ending with \texttt{.ppm} and opening it in a compatible image-viewing program should give a 3x3 (note that this means it may be quite small) image with 3 horizontal gray stripes.

\section*{What You Will Write}

You will be writing code that parses the metadata in the PPM header, up until the pixels.

\subsection*{Files}

This comprises editing the function \texttt{parse}, defined in \texttt{src/ppm.rs}. \emph{This is the only function need to edit---take a look at the \texttt{todo!}s}.

This function uses a state machine to parse the ppm file. We've set you up with a couple \texttt{enum}s which collectively represent the state of the machine to execute the parsing steps, as well as a description of what each state represents and what you'll need to do. Then, you can just edit the main loop in \texttt{parse} to do what the comments tell you.

The file \texttt{src/main.rs} is a harness that wraps your code and uses OpenGL to display the resulting parsed image. You can compare this with a standard utility to view images, like ImageMagick's \texttt{display}. \emph{You do not need to edit this file}.

\subsection*{Testing}

To test your code you can use the provided PPM files, as well as writing your own. We recommend printing out some smaller ones first, to ensure the parsed result is what you expect, but for the larger ones you will be able to visually compare. Most image viewing software should be able to open the PPMs, so you can use your image viewer of choice to confirm visually what you get when you run your Rust code is the same.

Additionally, we've incorporated some of the testing features in Cargo so you can automatically test your code on the provided files. Running \texttt{cargo test} will run these tests, which you can see at the bottom of \texttt{src/main.rs}.

\section*{Submitting}

Submission will be on Gradescope. If you aren't in gradescope, message us in Discord or via email at \href{mailto:rust-stuco-staff@lists.andrew.cmu.edu}{\texttt{rust-stuco-staff@lists.andrew.cmu.edu}}.

You should submit a zip file containing the whole crate rooted at the directory where Cargo.toml appears (e.g., run \texttt{zip submission.zip Cargo.toml src/*}) and upload that.

\end{document}
